\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[slovene]{babel}
\usepackage{lmodern} 
\usepackage{hyperref}
\usepackage{blindtext}
\usepackage{amsmath}  % razna okolja za poravnane enačbe ipd.
\usepackage{amsthm}   % definicije okolij za izreke, definicije, ...
\usepackage{amssymb}  % dodatni matematični simboli
\usepackage{listings} % okolje za Python kodo

\title{\textit{Grid-peeling}}
\author{Gašper Pust, Mitja Mandić}

\begin{document}
\lstset{language=Python, breaklines=true, numbers=left, columns=fullflexible, basicstyle=\ttfamily}
\begin{titlepage}
 \maketitle
% \thispagestyle{empty}
\end{titlepage}
%
%\pagebreak

\section{Predstavitev problema}
V projektu si bomo podrobneje ogledali konveksne ovojnice $m \times n$ mreže. Konveksna ovojnica množice je najmanjša konveksna množica, ki vsebuje dano množico.
Najlažje si jo predstavljamo tako, kot da bi okoli elementov množice napeli elastiko - kar elastika obkroži, je konveksna ovojnica. Lupljenje konveksnih ovojnic mreže,
oziroma angleško \textit{grid - peeling} je proces, ko iz mreže iterativno odstranjujemo konveksne ovojnice. S simboli lahko to zapišemo takole:
$ P_{0} = G_{n,m} = \{1,\ldots, n\} \times \{1, \ldots, m\}$. Naj bo $C_{i} = \mathcal{C}\mathcal{H}(P_{i-1}) \text{ za } i = 1, \ldots$. $V_{i}$ naj bo množica vozlišč $C_{i}$
- kot vozlišče razumemo točko, ki je na vogalu mreže (torej za katero bi zataknili elastiko). Naj bo sedaj $P_{i} = P_{i-1} \setminus V_{i}$. Začnemo torej z $n \times m$ mrežo 
in iterativno lupimo konveksne ovojnice, dokler ne odstranimo vseh točk.

V projektni nalogi bova s pomočjo simulacij opazovala v literaturi navedene številke za $n \times n$ mrežo - teorija napoveduje $\theta(n ^ \frac{4}{3})$ ovojnic.
Za $n \times m$ mrežo v literaturi ni navedenih podatkov, zanimala naju bo morebitna povezava. Simulacije bova izvedla tudi za točke na neenakomerni mreži.

Po izvedenem eksperimentalnem delu, bomo rezultate analizirali in jih primerjali z rezultati iz literature. Zanimalo nas bo, kako drugačno je število ovojnic na $m \times n$
mreži v primerjavi s simetrično.

\newpage
\section{Orodja in algoritmi}
Za uporabo algoritmov v Pythonu sva morala najprej definirati razred Točka, s katerim bova konstruirala vsa potrebna orodja in funkcije za uporabo algoritmov za iskanje konveksnih ovojnic.

\begin{lstlisting}
class Tocka:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def kot_med_dvema(self, other):
        if self.x != other.x:
            return (self.y - other.y) / (self.x - other.x)
        else:
            return 90

    def vektorski_produkt(self, other): 
        return self.x * other.y - self.y * other.x

    def razlika(self, other):
    	return Tocka(self.x - other.x, self.y - other.y)

    def smer_razlike(self, other, another):
        vekt_p = Tocka(self.x - other.x, self.y-other.y).vektorski_produkt(Tocka(another.x - other.x, another.y - other.y))
        if vekt_p > 0:
            return 1
        elif vekt_p < 0:
            return -1
        else:
            return 0
    
    def razdalja(self, other):
        return (self.x - other.x) ** 2 + (self.y - other.y) ** 2

    def __str__(self):
        return '(' + str(self.x) + ', ' + str(self.y) + ')'

    def uredi_po_kotu(seznam):
        prvi = seznam[0]
        return [prvi] + sorted(seznam[1:], key=lambda x: prvi.kot_med_dvema(x))
\end{lstlisting}

\subsection{Jarvisov obhod}
Jarvisov obhod (angl. \textit{Jarvis March}) ali algoritem zavijanja darila je postopek, ki dani množici točk poišče konveksno ovojnico v eni ali več dimenzijah (osredotočili se 
bomo na dve dimenziji). Algoritem se imenuje po R.A. Jarvisu, ki ga je objavil leta 1973. Časovna zahtevnost algoritma je $O(nh)$, kjer $n$ predstavlja število vseh točk, $h$ pa 
število točk, ki ležijo na konveksni ovojnici. V najslabšem primeru, ko so vse podane točke tudi elementi konveksne ovojnice, torej v primeru $h = n$, je njegova časovna zahtevnost 
$O(n^2)$. Jarvisov obhod se največkrat uporablja za majhne $n$ ali pa v primeru, ko pričakujemo, da bo $h$ zelo majhen glede na $n$.

\begin{lstlisting}
def jarvis_march(seznam):
    zacetna_tocka =  min(seznam, key = lambda tocka: tocka.x)
    indeks = seznam.index(zacetna_tocka)
    l = indeks
    rezultat = []
    rezultat.append(zacetna_tocka)
    while (True):
        q = (l + 1) % len(seznam)
        for i in range(len(seznam)):
            if i == l:
                continue
            d = seznam[i].smer_razlike(seznam[l],  seznam[q])
            if d > 0 or (d == 0 and seznam[i].razdalja(seznam[l]) > seznam[q].razdalja(seznam[l])):
                q = i
        l = q
        if l == indeks:
            break 
        rezultat.append(seznam[q])
    return rezultat
\end{lstlisting}

Algoritem najprej poišče najbolj levo točko (2. vrstica kode). Ustvarimo prazen seznam, v katerega bomo postopoma dodajali točke, ki jih bomo obiskali. Vanj najprej dodamo začetno točko,
potem pa od trenutne točke poiščemo največji levi ovinek in gremo v tisto točko (v primeru kolinearnosti, gremo v točko, ke je od naše točke najdlje). To točko dodamo v seznam in se postavimo
tja (del kode od 7. do 15. vrstice). To počnemo, dokler ne pridemo nazaj v začetno točko in takrat se algoritem ustavi.

%https://algorithmtutor.com/Computational-Geometry/Convex-Hull-Algorithms-Jarvis-s-March/

\subsection{Grahamov pregled}
Alternativa prejšnjemu algoritmu je tako imenovani Grahamov pregled (angl. \textit{Graham's scan}). Algoritem se imenuje po Ronaldu Grahamu, ki ga je objavil leta 1972. 
V primerjavi z Jarvisovim obhodom je Grahamov pregled hitrejši, saj ima časovno zahtevnost $O(n \log n)$.

\begin{lstlisting}
def graham_scan(seznam):
    urejene_tocke = uredi_po_kotu(seznam)
    ovojnica = []
    for tocka in urejene_tocke:
        while len(ovojnica) > 1 and ovojnica[-1].smer_razlike(ovojnica[-2], tocka) <= 0:
            ovojnica.pop()
        ovojnica.append(tocka)
    return ovojnica
\end{lstlisting}

Najprej točke iz seznama točk uredimo po kotu in ustvarimo prazen seznam, v katerega bomo dodajali točke, ki so v konveksni ovojnici. Za točko potem pogledamo (naredimo neki k mi ni čist
jasno) in dodamo točko v ovojnico. To storimo za vse točke v urejenem seznamu (od 4. do 7. vrstice).

\section{Grid-peel algoritem}
S pomočjo že omenjenih algoritmov sedaj lahko izpeljemo algoritem za luplenje konveksnih ovojnic. Glede na vrsto iskanja konveksnih ovojnic, torej po Jarvisovem ali 
Grahamovem načinu, ločimo dva algoritma, ki pa se razlikujeta le v koraku, v katerem iščemo konveksno ovojnico.

\begin{lstlisting}
def grid_peel_jarvis(m, n):
    mreza = [Tocka(i,j) for i in range(m) for j in range(n)]
    ovojnice = {}
    i = 0
    while mreza:
        ch = jarvis_march(mreza)
        nova = list(set(mreza) - set(ch))
        mreza = nova
        ovojnice[i] = ch
        i += 1
    return i, ovojnice
\end{lstlisting}
\begin{lstlisting}
def grid_peel_graham(m, n):
    mreza = [Tocka(i,j) for i in range(m) for j in range(n)]
    ovojnice = {}
    i = 0
    while mreza:
        ch = graham_scan(mreza)
        nova = list(set(mreza) - set(ch))
        mreza = nova
        ovojnice[i] = ch
        i += 1
    return i, ovojnice
\end{lstlisting}

\section{Rezultati}

\section{Zaključek}


\end{document}